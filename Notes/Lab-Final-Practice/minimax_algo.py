#minimax algorithm

#2 players
# Min -> decreases the chances of winning the game
# Max -> increases his chancces of winning the game

#result of the game is generated by a heauristic function - propogates from the leaf nodes back to the root node using backtracking
#at each node, selects max or min val dep. on whether it is the max or min player's turn

#minimax strategy follows depth-first-search(DFS) concept to traverse the game tree
#min and max alternate turns
#algo also backtracks to explore other paths & det. optimal move
#dfs approach ensures each path is explored fully before backtracking

#flow of minimax algo
#keeps on generating game tree/search tree till a limit
#compute the move using a heuristic function
#propogate the vals from the leaf node to the curr position following the minimax strategy

#node val selection
#if curr level == minimizing level (min's turn) -> node accepts minimum value from its successor node
#if curr level == maximizing level (max's turn) -> node accpets maximum value from its successor node

#key concept
#max tries to maximize the utility value
#min tries to minimize max's chances by reducing the utility value

# function minimax(node, depth, maximizingPlayer) is
#     if depth == 0 or node is a terminal node then
#         return static evaluation of node 
    
#     if MaximizingPlayer then // for Maximizer Player
#         maxEva = -infinity
#         for each child of node do 
#             eva = minimax(child, depth - 1, false)
#             maxEva = max(maxEva, eva) //gives the maximum value 
#         return maxEva 
#     else // for Minimizer Player 
#         minEva = +infinity
#         for each child of node do 
#             eva = minimax(child, depth - 1, true)
#             minEva = min(minEva, eva) //gives the minimum value 
#         return minEva

import math 

class node:
    def __init__(self, value=None):
        self.value = value
        self.children = []
        self.minimax_value = None 
        
class MinimaxAgent:
    def __init__(self, depth):
        self.depth = depth
        
    def formulate_goal(self, node):
        #in minimax - goal is to compute the minimax value for the root node
        return "goal reached" if node.minimax_value is not None else "searching"
    
    def act(self, node, environment):
        goal_status = self.formulate_goal(node)
        if goal_status == "goal reached":
            return f"minimax value for root node: {node.minimax_value}"
        else:
            return environment.compute_minimax(node, self.depth)
        
class Environment:
    def __init__(self, tree):
             self.tree = tree
             self.computed_nodes = []
             
    def get_percept(self, node):
        return node
    
    def compute_minimax(self, node, depth, maximizing_player=True):
        if depth == 0 or not node.children:
            self.computed_nodes.append(node.value)
            return node.value
        
        if maximizing_player:
            value = -math.inf
            for child in node.children:
                child_value = self.compute_minimax(child, depth - 1, False)
                value = max(value, child_value)
                
            node.minimax_value = value
            self.computed_nodes.append(node.value)
            return value
        else:
            value = math.inf
            for child in node.children:
                child_value = self.compute_minimax(child, depth - 1, True)
                value = min(value, child_value)
                
            node.minimax_value = value
            self.computed_nodes.append(node.value)
            return value
        
def run_agent(agent, environment, start_node):
    percept = environment.get_percept(start_node)
    agent.act(percept, environment)
        
#sample tree
root = node('A')
n1 = node('B')
n2 = node('C')
root.children = [n1, n2]
n3 = node('D')
n4 = node('E')
n5 = node('F')
n6 = node('G')
n1.children = [n3, n4]
n2.children = [n5, n6]
n7 = node(2)
n8 = node(3)
n9 = node(5)
n10 = node(9)
n3.children = [n7, n8]
n4.children = [n9, n10]
n11 = node(0)
n12 = node(1)
n13 = node(7)
n14 = node(5)
n5.children = [n11, n12]
n6.children = [n13, n14]

#define depth for the minimax
depth = 3

agent = MinimaxAgent(depth)
environment = Environment(root)

run_agent(agent, environment, root)

print("Computed Nodes:", environment.computed_nodes)
print("Minimax values:")
print("A:", root.minimax_value)
print("B:", n1.minimax_value)
print("C:", n2.minimax_value)
print("D:", n3.minimax_value)
print("E:", n4.minimax_value)
print("F:", n5.minimax_value)
print("G:", n6.minimax_value)
 
